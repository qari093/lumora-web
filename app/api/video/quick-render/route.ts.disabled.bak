import path from "path";
import fs from "fs";
import { NextResponse } from "next/server";

// Use relative paths instead of "@/..."
import { render } from "../../../../src/video-gen/ffmpeg-worker";
import { pickPreset, type PresetName } from "../../../../src/video-gen/presets";

export const dynamic = "force-dynamic";

type Body = {
  clips: string[];
  voice?: { file: string; gainDb?: number };
  music?: { file: string; gainDb?: number; duck?: any };
  srt?: { path: string };
  out: string;
  fps?: number;
  preset?: PresetName;
};

export async function POST(req: Request) {
  try {
    const body = (await req.json()) as Body;

    // Apply optional preset (only if provided)
    const preset = body.preset ? pickPreset(body.preset) : undefined;
    const fps = body.fps ?? (preset?.fps ?? 30);

    // Build a minimal render plan the worker understands
    const plan = {
      outPath: body.out,
      width: preset?.width ?? 1080,
      height: preset?.height ?? 1920,
      fps,
      color: preset?.color ?? { saturation: 1.06 },
      clips: (body.clips || []).map((file) => ({ file, fit: "cover" as const })),
      voice: body.voice,
      music: body.music,
      subtitles: body.srt ? { srtPath: body.srt.path, font: "Inter", outlinePx: 3, bottomPct: 12 } : undefined,
    };

    // Persist plan for debugging
    const planPath = path.resolve(".data/render/plan-api.json");
    fs.mkdirSync(path.dirname(planPath), { recursive: true });
    fs.writeFileSync(planPath, JSON.stringify(plan, null, 2), "utf8");

    // Run the render (synchronous within the route)
    render(planPath);

    // Return metadata
    const outAbs = path.resolve(plan.outPath);
    const bytes = fs.existsSync(outAbs) ? fs.statSync(outAbs).size : 0;

    return NextResponse.json({ ok: true, out: plan.outPath, bytes, planPath });
  } catch (err: any) {
    return NextResponse.json(
      { ok: false, error: String(err?.message || err) },
      { status: 500 }
    );
  }
}
