import { NextResponse } from "next/server";
import { PrismaClient, LedgerType } from "@prisma/client";

const prisma = new PrismaClient();

export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: { Allow: "OPTIONS, POST" } });
}

export async function POST(req: Request) {
  try {
    const { ownerId, amountCents, type, refType, refId, note } = await req.json();
    if (!ownerId || typeof amountCents !== "number" || amountCents <= 0)
      return NextResponse.json({ ok: false, error: "ownerId and positive amountCents required" }, { status: 400 });

    const debitType: LedgerType = (type as LedgerType) || "AD_SPEND";

    const wallet = await prisma.wallet.findFirst({ where: { ownerId, currency: "EUR" } });
    if (!wallet)
      return NextResponse.json({ ok: false, error: "Wallet not found" }, { status: 404 });

    // Idempotency check
    if (refType && refId) {
      const existing = await prisma.walletLedger.findFirst({ where: { walletId: wallet.id, refType, refId } });
      if (existing)
        return NextResponse.json({
          ok: true, idempotent: true, charged: false,
          walletId: wallet.id, ledgerId: existing.id, refType, refId,
        });
    }

    const result = await prisma.$transaction(async (tx) => {
      const fresh = await tx.wallet.findUnique({ where: { id: wallet.id } });
      if (!fresh) throw new Error("Wallet disappeared");
      const nextBalance = fresh.balanceCents - amountCents;

      const row = await tx.walletLedger.create({
        data: { walletId: wallet.id, type: debitType, amountCents, refType, refId, note },
      });
      const updated = await tx.wallet.update({
        where: { id: wallet.id },
        data: { balanceCents: nextBalance },
      });
      return { row, balanceAfter: updated.balanceCents };
    });

    return NextResponse.json({
      ok: true, charged: true, walletId: wallet.id,
      ledgerId: result.row.id, amountCents, type: debitType,
      balanceAfterCents: result.balanceAfter, refType, refId,
    });
  } catch (err: any) {
    return NextResponse.json({ ok: false, error: String(err?.message || err) }, { status: 500 });
  }
}
