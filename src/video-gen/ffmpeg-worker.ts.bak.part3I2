
// FFmpeg worker (ESM-safe). Reads a render plan JSON and renders MP4.
//
// - Scales to 1080x1920 (9:16), concatenates clips
// - Optional SRT subtitles (libass)
// - Voice + music: normalize to stereo/48k and mix safely (static ducking)
// - ESM entry-safe (no require.main)

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { spawnSync } from "child_process";

type Clip = {
  file: string;
  start?: number; // seconds in source file
  end?: number;   // seconds in source file
  fit?: "cover" | "contain"; // how to fill 9:16
  speed?: number; // playback speed (e.g. 1.05)
};

type Transition = { at: number; type: "crossfade" | "whip"; dur: number }; // reserved (v2)

type Plan = {
  outPath: string;
  width: number;  // e.g. 1080
  height: number; // e.g. 1920
  fps: number;    // e.g. 30
  bgColor?: string; // "#000000"
  color?: { saturation?: number };
  clips: Clip[];
  transitions?: Transition[];
  voice?: { file: string; gainDb?: number };
  music?: {
    file: string;
    gainDb?: number;
    duck?: { amountDb?: number }; // static ducking amount if voice present (negative)
  };
  subtitles?: {
    srtPath: string;
    font?: string;        // e.g. "Inter"
    sizePct?: number;     // not used by libass force_style; keep default size
    outlinePx?: number;   // 0..8
    bottomPct?: number;   // margin from bottom in %
  };
};

// ---------- small helpers ----------
function sh(cmd: string, args: string[]) {
  const r = spawnSync(cmd, args, { stdio: "inherit" });
  if (r.status !== 0) throw new Error(`${cmd} failed (exit ${r.status})`);
}

function ensureDir(p: string) {
  fs.mkdirSync(path.dirname(p), { recursive: true });
}

function escapeFF(s: string) {
  // escape characters that break ffmpeg filter args
  return s.replace(/:/g, "\\:").replace(/,/g, "\\,");
}

function dbToAmp(db: number) {
  // convert dB to linear factor for ffmpeg volume=
  return `${Math.pow(10, db / 20).toFixed(3)}`;
}

// ---------- filter builders ----------
function buildVideoFilters(plan: Plan, clipInputIdx: number[]) {
  const w = plan.width, h = plan.height, fps = plan.fps;
  const bgHex = (plan.bgColor ?? "#000000").replace("#", "0x");
  const sat = plan.color?.saturation ?? 1.0;

  const parts: string[] = [];
  const labels: string[] = [];

  // Prepare each input clip -> [v{i}]
  clipInputIdx.forEach((idx, i) => {
    const c = plan.clips[i];
    const doTrim = typeof c.start === "number" || typeof c.end === "number";
    const trim =
      doTrim
        ? `trim=${typeof c.start === "number" ? `start=${c.start}` : ""}:${typeof c.end === "number" ? `end=${c.end}` : ""},setpts=PTS-STARTPTS`
        : `setpts=PTS-STARTPTS`;

    const speed = c.speed && c.speed !== 1 ? `,setpts=PTS/${c.speed}` : "";

    const vfFit =
      c.fit === "contain"
        ? `scale=${w}:-2:flags=lanczos,pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:${bgHex}`
        : `scale=${w}:-2:flags=lanczos,crop=${w}:${h}`;

    const vf = `[${idx}:v]${trim}${speed},fps=${fps},format=yuv420p,${vfFit},eq=saturation=${sat}[v${i}]`;
    parts.push(vf);
    labels.push(`voice${i}`);
  });

  // Concat all prepared video segments
  let vOut = "vout";
  if (labels.length === 1) {
    parts.push(`[${labels[0]}]fps=${fps},format=yuv420p[${vOut}]`);
  } else if (labels.length > 1) {
    const chain = labels.map((l) => `[${l}]`).join("");
    parts.push(`${chain}concat=n=${labels.length}:v=1:a=0,format=yuv420p[${vOut}]`);
  } else {
    // no video inputs – synth a black stream
    parts.push(`color=c=${bgHex}:size=${w}x${h}:rate=${fps}[${vOut}]`);
  }

  // Optional SRT burn
  if (plan.subtitles?.srtPath && fs.existsSync(plan.subtitles.srtPath)) {
    const sub = plan.subtitles;
    const outline = Math.max(0, Math.min(8, sub.outlinePx ?? 3));
    const bottomPct = Math.max(5, Math.min(20, sub.bottomPct ?? 12));
    const marginV = Math.round(h * bottomPct / 100);

    // NOTE: libass uses ASS style; font size must be absolute, not pct. We leave default.
    const forceStyle = [
      sub.font ? `Fontname=${sub.font}` : "",
      `Outline=${outline}`,
      `Alignment=2`,           // bottom-center
      `MarginV=${marginV}`
    ].filter(Boolean).join(",");

    parts.push(
      `[${vOut}]subtitles=${escapeFF(sub.srtPath)}:force_style=${escapeFF(forceStyle)}[vsub]`
    );
    vOut = "vsub";
  }

  return { filter: parts.join(";"), videoLabel: vOut };
}

function buildAudioFilters(plan: Plan, firstAudioIndex: number) {
  const parts: string[] = [];
  const inputs: string[] = [];
  let aOut = "aout";
  let idx = firstAudioIndex;

  // helper: dB -> linear amplitude
  const dbToAmpNum = (db: number) => Math.pow(10, db / 20);

  // voice -> [v]
  if (plan.voice?.file && fs.existsSync(plan.voice.file)) {
    const gain = dbToAmpNum(plan.voice.gainDb ?? 1);
    parts.push(
      `[${idx}:a]aformat=sample_fmts=s16:channel_layouts=stereo,aresample=48000,volume=${gain.toFixed(3)}[v]`
    );
    inputs.push("voice");
    idx++;
  }

  // music (optionally duck)
  if (plan.music?.file && fs.existsSync(plan.music.file)) {
    const baseGain = dbToAmpNum(plan.music.gainDb ?? -8);
    parts.push(
      `[${idx}:a]aformat=sample_fmts=s16:channel_layouts=stereo,aresample=48000,volume=${baseGain.toFixed(3)}[music0]`
    );
    idx++;

    let musicLabel = "music0";

    const d: any = plan.music.duck;
    const hasDynamic = d && (
      typeof d.thresholdDb === "number" ||
      typeof d.ratio === "number" ||
      typeof d.attack === "number" ||
      typeof d.release === "number"
    );
    const hasStatic = d && typeof d.amountDb === "number";

    if (hasDynamic && inputs.includes("voice")) {
      // Convert dB threshold (e.g. -22 dB) -> linear (0..1)
      const thrDb = Number.isFinite(d.thresholdDb) ? d.thresholdDb : -24;
      let thr = dbToAmpNum(thrDb);
      if (thr < 1/1024) thr = 1/1024;  // guard FFmpeg range
      if (thr > 1) thr = 1;

      const ratio   = Math.max(1,  Math.min(20,   d.ratio   ?? 8));
      const attack  = Math.max(1,  Math.min(200,  d.attack  ?? 5));
      const release = Math.max(10, Math.min(2000, d.release ?? 180));
      const knee    = Math.max(0,  Math.min(8,    d.knee    ?? 2));
      const makeup=1;

      parts.push(
        `[${musicLabel}][v]sidechaincompress=threshold=${thr.toFixed(6)}:ratio=${ratio}:attack=${attack}:release=${release}:knee=${knee}:makeup=1[ducked]`
      );
      musicLabel = "ducked";
    } else if (hasStatic) {
      const amtDb = d.amountDb as number;     // e.g. -8
      const lin   = dbToAmpNum(amtDb);
      parts.push(`[${musicLabel}]volume=${lin.toFixed(3)}[ducked]`);
      musicLabel = "ducked";
    }

    // expose final music label as [music]
    parts.push(`[${musicLabel}]anull[music]`);
    inputs.push("music");
  }

  // Mixdown / or generate silence
  if (inputs.length === 0) {
    parts.push(`anullsrc=r=48000:cl=stereo[${aOut}]`);
  } else if (inputs.length === 1) {
    parts.push(`[${inputs[0]}]aresample=async=1:first_pts=0[${aOut}]`);
  } else {
    parts.push(
      `[${inputs[0]}][${inputs[1]}]amix=inputs=2:normalize=0,aresample=async=1:first_pts=0[${aOut}]`
    );
  }

  return { filter: parts.join(";"), audioLabel: aOut, nextIdx: idx };
}// ---------- main render ----------
function render(planPath: string) {
  if (!fs.existsSync(planPath)) throw new Error(`Plan not found: ${planPath}`);
  const plan = JSON.parse(fs.readFileSync(planPath, "utf8")) as Plan;

  if (!plan.width || !plan.height || !plan.fps) {
    throw new Error("Plan must specify width, height, fps");
  }
  ensureDir(plan.outPath);

  const args: string[] = ["-y", "-v", "info"];

  // inputs: all clips first
  const clipInputIdx: number[] = [];
  plan.clips.forEach((c, i) => {
    if (!fs.existsSync(c.file)) throw new Error(`Clip missing: ${c.file}`);
    args.push("-i", c.file);
    clipInputIdx.push(i);
  });

  // inputs: audio (voice, music) after video inputs
  let audioStart = clipInputIdx.length;
  if (plan.voice?.file && fs.existsSync(plan.voice.file)) args.push("-i", plan.voice.file);
  if (plan.music?.file && fs.existsSync(plan.music.file)) args.push("-i", plan.music.file);

  // filter_complex
  const voice = buildVideoFilters(plan, clipInputIdx);
  const a = buildAudioFilters(plan, audioStart);
  const filterComplex = [v.filter, a.filter].filter(Boolean).join(";");

  // wire filters + maps
  args.push("-filter_complex", filterComplex);
  args.push("-map", `[${voice.videoLabel}]`, "-map", `[${a.audioLabel}]`);

  // codecs + output
  args.push(
    "-c:v", "libx264",
    "-profile:v", "high",
    "-pix_fmt", "yuv420p",
    "-crf", "18",
    "-preset", "medium",
    "-r", String(plan.fps),
    "-c:a", "aac",
    "-b:a", "192k",
    "-shortest",  // stop when the shortest stream ends
    plan.outPath
  );

  console.log("⏺️  ffmpeg", args.join(" "));
  sh("ffmpeg", args);
  console.log("✅ Render complete:", plan.outPath);
}

// ---------- ESM entry (no require.main) ----------
const __self = fileURLToPath(import.meta.url);
if (process.argv[1] && path.resolve(process.argv[1]) === path.resolve(__self)) {
  const p = process.argv[2];
  if (!p) {
    console.error("Usage: npx tsx src/video-gen/ffmpeg-worker.ts <renderPlan.json>");
    process.exit(1);
  }
  render(path.resolve(p));
}

export { render };
